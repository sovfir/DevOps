#!/bin/bash

# Задает время начала скрипта
start_time=$(date +%s.%N)

function ft_name_generator() {
    # используется для генерации случайных имен с использованием заданных символов.
    local chars="$1"
    # В этой строке аргумент функции $1, который представляет символы, используемые для генерации имени, присваивается локальной переменной chars.
    local min_length=4
    # Здесь задается минимальная длина имени, которая равна 4 символам.
    local name=""
    # Создается локальная переменная name, которая инициализируется пустой строкой.
    
    # Этот цикл выполняется min_length раз (4 раза в данном случае), чтобы сгенерировать имя указанной длины.
    for ((i=0; i<$min_length; i++)); do
        name="${name}${chars:$((RANDOM % ${#chars})):1}"
        # Внутри цикла генерируется случайный символ из строки chars. 
        # RANDOM % ${#chars} вычисляет случайное число в диапазоне от 0 до длины строки chars - 1, и ${chars:...:1} извлекает символ по указанному индексу. Полученный случайный символ добавляется к текущему значению переменной name.
    done
    
    echo "${name}"
    # В конце функции выводится сгенерированное имя.
}

# используется для проверки наличия свободного места на диске перед созданием файлов.
function ft_spacecheck() {
    local available_space=$(df --output=avail / | tail -1)
    # В этой строке выполняется команда df для получения информации о доступном свободном месте на корневом разделе диска (/). 
    # Опция --output=avail указывает команде df выводить только доступное свободное место. Результат команды передается в переменную available_space с помощью конструкции $(...).
    local min_space=$((1024 * 1024))
    # В этой строке создается локальная переменная min_space, которой присваивается значение, равное 1 гигабайту (1024 * 1024 байт).
    
    if [[ $available_space -lt $min_space ]]; then
        # В этой строке происходит проверка, если доступное свободное место $available_space меньше, чем минимальное необходимое свободное место $min_space.
        echo "Error: Not enough free space to make files."
        exit 1
    fi
}

# 2) Функция для создания папок и файлов
function ft_create_folders_and_files() {
    local base_path="$1"
    # В этой строке значение первого аргумента функции ($1) присваивается локальной переменной base_path. 
    # Переменная base_path будет содержать путь к основной директории, в которой будут создаваться папки и файлы.
    local num_folders="$2"
    # В этой строке значение второго аргумента функции ($2) присваивается локальной переменной num_folders. 
    # Переменная num_folders будет содержать количество папок, которые нужно создать.
    local folder_chars="$3"
    # Переменная folder_chars будет содержать символы, которые будут использоваться для генерации имен папок.
    local num_files="$4"
    # Переменная num_files будет содержать количество файлов, которые нужно создать в каждой папке.
    local file_chars="$5"
    # Переменная file_chars будет содержать символы, которые будут использоваться для генерации имен файлов.
    local ext_chars="${file_chars:0:3}"
    # Переменная ext_chars будет содержать первые три символа из file_chars и будет использоваться для генерации расширений файлов.
    local file_size_kb="$6"
    # Переменная file_size_kb будет содержать размер файла в килобайтах.
    local log_file="$7"
    # Переменная log_file будет содержать путь к файлу, в который будут записываться логи создания файлов.
    local date_suffix=$(date '+%d%m%y')
    # В этой строке значение текущей даты в формате "деньмесяцгод" присваивается локальной переменной date_suffix. $(date '+%d%m%y') используется для получения текущей даты.
    
    # Создаем подпапки. Этот цикл будет выполняться num_folders раз, итерируя по переменной i.
    for ((i=0; i<$num_folders; i++)); do
        ft_spacecheck
        
        local folder_name="$(ft_name_generator "$folder_chars")_${date_suffix}"
        # В этой строке используется функция ft_name_generator, которая генерирует имя папки на основе символов из folder_chars. 
        # Имя папки затем будет дополнено значением date_suffix для создания уникального имени. Значение присваивается локальной переменной folder_name.
        local folder_path="${base_path}/${folder_name}"
        # В этой строке формируется путь к создаваемой папке, объединяя значение base_path (корневой путь) и значение folder_name.
        mkdir -p "$folder_path"
        # Эта строка создает папку с помощью команды mkdir. Флаг -p гарантирует, что будут созданы все промежуточные папки, если они не существуют.
        
        # Цикл создания файлов внутри папок.
        for ((j=0; j<$num_files; j++)); do
            ft_spacecheck
            
            local file_name="$(ft_name_generator "$file_chars")_${date_suffix}"
            # здесь генерируется имя файла с использованием функции ft_name_generator и добавляется значение date_suffix.
            local file_ext="$(ft_name_generator "$ext_chars")"
            # В этой строке генерируется расширение файла, используя функцию ft_name_generator с аргументом ext_chars. Значение присваивается локальной переменной file_ext.
            local file_path="${folder_path}/${file_name}.${file_ext}"
            # В этой строке формируется полный путь к создаваемому файлу, объединяя путь folder_path, имя файла file_name и расширение файла file_ext.
            
            truncate -s "${file_size_kb}K" "$file_path"
            # Эта строка использует команду truncate для создания файла указанного размера (file_size_kb). 
            # Опция -s указывает размер файла, аргументом которого является значение file_size_kb. Путь к файлу указывается с помощью переменной file_path.
            echo "$(date '+%Y-%m-%d %H:%M:%S') | Created: ${file_path} | Size: ${file_size_kb}K" >> "$log_file"
            # В этой строке записывается информация о созданном файле в лог-файл. 
            # С помощью echo формируется строка, содержащая текущую дату и время, путь к созданному файлу и его размер. Затем строка добавляется в файл, указанный в переменной log_file, с помощью оператора перенаправления >>.
        done
    done
}
# 1) Стартуем от главной функции 
function main() {
    if [[ $# -ne 6 ]]; then
    # if [[ $# -ne 6 ]]; then: Эта строка проверяет количество переданных аргументов скрипту. "$#" -ne 6 означает, что если количество аргументов не равно 6, то условие выполнено.
        echo "Error: We need Arguments!."
    # echo "Error: We need Arguments!": Если условие в строке 1 истинно (то есть количество аргументов не равно 6), то эта строка выводит сообщение об ошибке "Ошибка: требуются аргументы".
        echo "      Usage: $0 <absolute_path> <num_folders> <folder_chars> <num_files> <file_chars> <file_size_kb>"
    # Эта строка выводит сообщение с примером использования скрипта. $0 представляет собой имя самого скрипта.
        exit 1
    # exit 1: Эта команда прекращает выполнение скрипта с кодом возврата 1, указывая на ошибку.
    fi
    # Таким образом, эта часть скрипта проверяет, что ему были переданы все необходимые аргументы (в данном случае 6 аргументов). 
    # Если это не так, он выводит сообщение об ошибке и завершает свою работу с кодом возврата 1.

    
    # Пихаем параметры в переменные
    local base_path="$1"
    local num_folders="$2"
    local folder_chars="$3"
    local num_files="$4"
    local file_chars="$5"
    local file_size_kb="$6"
    # Данный блок кода использует команду local для объявления локальных переменных внутри функции main(). 
    # В этом случае переменные присваивают значения из переданных аргументов скрипта.
    # local base_path="$1": Создает локальную переменную base_path и присваивает ей значение первого аргумента скрипта ($1).
    # Эти локальные переменные будут доступны только внутри функции main() и не будут пересекаться с переменными с такими же именами извне функции.
    

    # Этот блок кода проверяет, являются ли значения переменных $num_folders, $num_files и $file_size_kb числами.
    if ! [[ $num_folders =~ ^[0-9]+$ ]] || ! [[ $num_files =~ ^[0-9]+$ ]] || ! [[ $file_size_kb =~ ^[0-9]+$ ]]; then
        # В этой строке происходит проверка на то, являются ли значения переменных числами. Каждая переменная проверяется с помощью конструкции ! [[ переменная =~ ^[0-9]+$ ]], 
        # которая использует регулярное выражение ^[0-9]+$ для проверки, что переменная состоит только из цифр. Если хотя бы одна из переменных не является числом, то условие выполнено.
        echo "Error: One of the arguments is not a number."
        echo "      Usage: $0 <absolute_path> <num_folders> <folder_chars> <num_files> <file_chars> <file_size_kb>"
        # Эта строка выводит сообщение с примером использования скрипта. $0 представляет собой имя самого скрипта.
        exit 1
    fi

    # Этот блок кода проверяет, что значение переменной $file_size_kb не превышает 100 (килобайт).
    if [[ $file_size_kb -gt 100 ]]; then
    # В этой строке происходит сравнение значения переменной $file_size_kb с числом 100. 
    # Оператор -gt означает "больше". Если значение переменной $file_size_kb больше 100, то условие выполнено.
        echo "Error: File size is bigger then 100KB."
        exit 1
    fi
    
    local log_file="${base_path}/creation_log_$(date '+%d%m%y').txt"
    # В этой строке переменной log_file присваивается значение, которое состоит из base_path (значение переменной base_path) и строки /creation_log_$(date '+%d%m%y').txt.
    # $(date '+%d%m%y') представляет собой команду, которая будет заменена текущей датой в формате "деньмесяцгод". 
    # Затем это значение используется для создания имени файла, например, creation_log_170623.txt. Таким образом, log_file будет содержать полный путь и имя файла для записи логов.
    ft_create_folders_and_files "$base_path" "$num_folders" "$folder_chars" "$num_files" "$file_chars" "$file_size_kb" "$log_file"
    # Передаем переменные в функцию для создания папок и файлов
}

main "$@"
# В этом блоке кода происходит вызов функции main с аргументами командной строки "$@". Аргументы командной строки передаются в функцию main для обработки.

# Вычисляем время работы скрипта
end_time=$(date +%s.%N)
# Эта строка сохраняет текущее время в переменную end_time с помощью команды date. Опция %s.%N указывает формат вывода времени в секундах с десятичной частью (наносекунды).
elapsed_time=$(echo "$end_time - $start_time" | bc)
# В этой строке происходит вычисление разницы между временем end_time и start_time с помощью команды echo и инструмента bc, который используется для выполнения арифметических вычислений в командной строке. 
# Результат сохраняется в переменную elapsed_time.
echo "Script execution duration (seconds) = $elapsed_time"
# Эта строка выводит сообщение с временем выполнения скрипта в секундах.
