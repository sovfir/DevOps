#!/bin/bash

function delete_path() {
    local file_path="$1"
    #Путь к файлу или директории передается в функцию как аргумент и сохраняется в локальной переменной $file_path.
    
    if [[ -f "$file_path" ]]; then
    #Это условное выражение проверяет, является ли $file_path путем к существующему файлу. Если это файл, выполняются действия внутри блока then.
        rm -f "$file_path"
        #Используется команда rm для удаления файла по указанному пути. Флаг -f гарантирует удаление без запроса подтверждения.
        echo "file is eliminated: $file_path"
        elif [[ -d "$file_path" ]]; then
        #Это условное выражение проверяет, является ли $file_path путем к существующей директории. Если это директория, выполняются действия внутри блока then.
        rm -rf "$file_path"
        #Используется команда rm для рекурсивного удаления директории по указанному пути и её содержимого. 
        #Флаги -rf обеспечивают удаление без запроса подтверждения и рекурсивное удаление всех файлов и поддиректорий.
        echo "directory is eliminated: $file_path"
    fi
}

function delete_via_log_path() {
    local log_file="$1"
    #Присваиваем поданный путь переменной
    
    if [[ ! -f "$log_file" ]]; then
        echo "Error: NO LOG FILE!!!: $log_file"
        exit 1
    fi
    #Проверяем подан ли аргумент
    
    declare -A catalogs
    #Объявляется ассоциативный массив с именем catalogs. В этом массиве будут храниться родительские каталоги файлов, указанных в логах.
    
    while read -r line; do
    #Цикл while читает файл журнала построчно.
        local file_path=$(echo "$line" | awk -F'|' '{print $2}' | awk '{print $2}')
        #Извлекается путь к файлу из строки журнала. Для этого используется команда awk, которая разделяет строку по символу | и извлекает второе поле, а затем удаляются лишние пробелы.
        local parent_dir=$(dirname "$file_path")
        #Получается путь к родительскому каталогу файла с помощью команды dirname.
        
        if [[ -e "$file_path" ]]; then
        #Это условное выражение проверяет, существует ли файл по указанному пути. Если файл существует, выполняются следующие действия в блоке
            delete_path "$file_path"
        fi
        
        
        catalogs["$parent_dir"]=1
        #Родительский каталог добавляется в ассоциативный массив directories с ключом, равным пути к родительскому каталогу.
    done < "$log_file"
    #Завершается цикл while, который проходит по всем строкам файла журнала.
    
    
    for dir in "${!catalogs[@]}"; do
    #Цикл for проходит по всем ключам (родительским каталогам) в ассоциативном массиве
        if [[ -d "$dir" ]]; then
        #Это условное выражение проверяет, существует ли каталог по указанному пути. Если каталог существует, выполняются следующие действия в блоке
            delete_path "$dir"
            #Если да, то все удаляем
        fi
    done
    
    rm -f "$log_file"
    #удаляем log
}



function delete_by_creation_date_and_time() {
    local start_time="$1"
    local end_time="$2"
    #Функция получает два аргумента - начальное время start_time и конечное время end_time, указанные пользователем при вызове функции. Они сохраняются в локальных переменных.
    
    local start_timestamp=$(date -d "$start_time" +%s)
    local finish_timestamp=$(date -d "$end_time" +%s)
    #Используя команду date, заданные временные значения преобразуются в формат UNIX-времени (количество секунд, прошедших с 1 января 1970 года). 
    #Результат сохраняется в локальных переменных start_timestamp и end_timestamp.
    
    #Данная строка выполняет поиск файлов в директории $(pwd)/../02/log с помощью команды find. Опции -type f указывают на то, что нужно искать только файлы, а не директории.
    #Формат вывода определяется с помощью опции -printf. В данном случае используется формат %Ts|%p\n, где:
    #%Ts - время создания файла в формате UNIX-времени (количество секунд, прошедших с 1 января 1970 года);
    #%p - путь к файлу. Результаты поиска выводятся в формате времени создания файла, за которым следует разделитель |, а затем путь к файлу. В конце каждой строки добавляется символ новой строки \n.
    #Опция 2>/dev/null перенаправляет сообщения об ошибках (stderr) в /dev/null, то есть игнорирует их и не выводит на экран.
    #Далее, результаты поиска передаются через конвейер | в цикл while read -r line, где каждая строка результата записывается в переменную line.
    #Цикл while выполняет последующие действия с каждой строкой результата. В вашем случае, строки разбиваются на две части с разделителем |, и значения сохраняются в локальных переменных created_timestamp (время создания) и file_path (путь к файлу).
    #Таким образом, данная строка выполняет поиск файлов в указанной директории и последовательно обрабатывает каждый найденный файл в цикле while.
    find $(pwd)/../02/log -type f -printf "%Ts|%p\n" 2>/dev/null | while read -r line; do
    
        local created_timestamp=$(echo "$line" | awk -F'|' '{print $1}')
        #Строка, полученная из find, разбивается на время создания и путь к файлу или директории. Эти значения сохраняются в локальных переменных created_timestamp и file_path.
        local file_path=$(echo "$line" | awk -F'|' '{print $2}')
        
        
        if [[ "$created_timestamp" -gt "$start_timestamp" && "$created_timestamp" -lt "$finish_timestamp" ]]; then
        #Выполняется проверка, находится ли время создания файла или директории внутри заданного временного диапазона. Если это так, выполняются действия внутри блока then.
            if [[ -e "$file_path" ]]; then
            #Проверяется, существует ли файл или директория по указанному пути. Если объект существует, выполняются действия внутри блока
                delete_path "$file_path"
            fi
        fi
    done
}

function delete_by_name_mask() {
    local name_mask="$1"
    #Функция получает аргумент name_mask, который представляет собой заданную пользователем маску имени. Этот аргумент сохраняется в локальной переменной.
    
    
    find / -not \( -path /bin -prune -o -path /sbin -prune \) -type f,d -name "${name_mask}*" 2>/dev/null | while read -r file_path; do
    #Используя команду find, выполняется поиск файлов и директорий в указанной директории (в данном случае корневой директории /). 
    #Опции -not, -path, -prune и -type используются для исключения некоторых директорий, таких как /bin и /sbin, чтобы избежать удаления системных файлов. 
    #Опция -name указывает маску имени для поиска. Результат передается через пайп (|) для обработки в цикле while.
        if [[ -e "$file_path" ]]; then
            delete_path "$file_path"
        fi
    done
}

function main() {
    if [[ $# -ne 1 ]]; then
        #Это условное выражение проверяет, равно ли количество аргументов командной строки ($#) единице. 
        #Если это условие истинно, то означает, что не был передан ожидаемый один аргумент.
        echo "Error: NO Arguments!!!"
        echo "      Usage: $0 <cleaning_type>"
        #Выводится сообщение, объясняющее правильное использование скрипта, включая ожидаемый аргумент 
        echo "      Choose cleaning method: ENTER 1 (by log file), ENTER 2 (by creation date and time), ENTER 3 (by name mask)"
        exit 1
    fi
    
    local cleaning_type="$1"
    #Присваиваем аргумент переменной
    
    if [[ $cleaning_type -eq 1 ]]; then
        #Это условное выражение проверяет, равно ли значение переменной $cleaning_type 1. Если это условие истинно, выполняются следующие шаги 
        echo "Enter the path to the log file:"
        #Выводится приглашение пользователю ввести путь к файлу лога.
        read -r log_file
        #Пользователю предоставляется возможность ввести путь к файлу лога, и введенное значение сохраняется в переменной $log_file.
        delete_via_log_path "$log_file"
        elif [[ $cleaning_type -eq 2 ]]; then
        #Это условное выражение проверяет, равно ли значение переменной $cleaning_type 2. Если это условие истинно, выполняются следующие шаги 
        echo "Enter the start date and time (input format: YYYY-MM-DD HH:MM):"
        read -r start_time
        #Пользователю предоставляется возможность ввести дату старта
        echo "Enter the end date and time (format: YYYY-MM-DD HH:MM):"
        read -r end_time
        #Пользователю предоставляется возможность ввести дату финиша
        delete_by_creation_date_and_time "$start_time" "$end_time"
        elif [[ $cleaning_type -eq 3 ]]; then
        #Это условное выражение проверяет, равно ли значение переменной $cleaning_type 3. Если это условие истинно, выполняются следующие шаги 
        echo "Enter the name mask (format: characters_date, e.g. azzzz_121121):"
        read -r name_mask
        #считываем аргумент в переменную
        delete_by_name_mask "$name_mask"
    else
        echo "Error: Invalid input cleaning method."
        echo "      Usage: $0 1, 2, or 3."
        echo "      Cleaning method: ENTER 1 (by log file), ENTER 2 (by creation date and time), ENTER 3 (by name mask)"
        exit 1
    fi
}

main "$@"